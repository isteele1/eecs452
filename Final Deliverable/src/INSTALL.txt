Ultrasonic Anti-Spoofing Algorithm
==========================
This file provides documentation on setup, compilation, and installation of the tools required in the project.

Setting Up the STM32
–––––––––––––––
1. Prerequisites
  • Software
    - STM32CubeIDE (v1.15.0+)
    - ST-LINK/V2 Drivers
    - Some Serial Terminal (e.g ArduinoIDE, PuTTY, Tera Term)
  • Hardware
    - NUCLEO-L4R5ZI-P
    - 2x HC-SR04 ultrasonic sensors
    - 12 Jumper wires (10 Female-to-Male, 2 Male-to-Male)
    - A breadboard

2. Project Setup in STM32CubeIDE
  1) Create New Project
    • File --> New --> STM32 Project
    • Select "NUCLEO-L4R5ZI-P" from board selector
    • Set project name (e.g., "Ultrasonic_Spoof_Detect")
    • Select C++ as the Targeted Language
  2) Import Source Files
    • Right-click project --> Import --> General --> File System
    • Add these files to Core/Inc folder
      - HoltEMA.h
      - kiss_fft.h
      - _kiss_fft_guts.h
      - stm32l4xx_it.h
      - stm32l4xx_hal_conf.h
    • Add these files to Core/Src folder
      - HOLTEMA.cpp
      - stm32l4xx_hal_msp.c
      - stm32l4xx_it.c
      - syscalls.c
      - sysmem.c
3) Configure Target MCU
  • In the .ioc file
    - Clock: 120MHz
    - GPIO: PC8: GPIO_OUTPUT
            PC9: GPIO_INPUT
            PC10: GPIO_OUTPUT
            PC11: GPIO_INPUT
            PF5: GPIO_EXTI5
    - LPUART1: 115200, 8N1

3. Hardware Connections
  • Attacker ultrasonic sensor
    - Trig of Attacker --> PC8
    - Echo of Attack --> PC9
  • Defender ultrasonic sensor
    - Trig of Attacker --> PC10
    - Echo of Attack --> PC11
  • External Button
    - One terminal --> GND
    - Other terminal --> PF5

4. Code Configuration
  • Critical Settings in main.cpp (Ensure these match your hardware)
    #define TRIG_PIN_ATTACK GPIO_PIN_8
    #define ECHO_PIN_ATTACK GPIO_PIN_9
    #define TRIG_PIN_DEFEND GPIO_PIN_10
    #define ECHO_PIN_DEFEND GPIO_PIN_11
  • Build Settings
    -  Project --> Properties --> C/C++ Build --> Settings
      • Toolchain: STM32 MCU GCC
      • Preprocessor __GNUC__, USE_HAL_DRIVER
      • Miscellaneous: -std=c++17

5. Flashing the Firmware
  1) Connect board via USB
  2 In STM32CubeIDE
    • Project --> Build All
    • Run --> Debug Configuration --> STM32 Cortex-M C/C++ Application
    • Click "Debug"

6. Serial Monitoring
  1) Open Serial terminal (115200 baud, 8N1)
  2) Expected output:
      15.23 14.98   // Raw and filtered distances
      0.12 0.45 ...  // FFT bins

7. Attack Mode Control
  • Press the button connected to PF5 to cycle mode
    - Disable attacks --> Jamming (25ms intervals) --> Random (25 - 150ms intervals) --> Disable attacks

Troubleshooting
• Issue: No serial output
  - Solution: Check LPUART1 config and TX/RX connections. Also consider restarting your serial monitor and the STM32
• Issue: Sensor not responding
  - Solution: Verify 5V power and trigger/echo wiring
• Issue: FFT artifacts
  - Solution: Adjust N and L in main.cpp

Documentation References
• NUCLEO-L4R5ZI-P User Manual (https://www.st.com/resource/en/user_manual/um2179-stm32-nucleo144-boards-mb1312-stmicroelectronics.pdf)
• STM32CubeIDE Debugging Guide (https://01001000.xyz/2020-05-11-Tutorial-STM32CubeIDE-Getting-started/)
• kissfft repository by mborgerding (https://github.com/mborgerding/kissfft)


Setting Up Python Plotting
–––––––––––––––
Make sure the proper dependencies for the Python file have been installed. Go to a Unix terminal in the same directory as plotting.py and run:
>> pip install pyserial matplotlib numpy

Plug in the STM32 to your PC and find its COM port by running:
>> python3 plotting.py --port COM3

Enter this port name into the top of plotting.py. Run the program in your Python IDE of choice.
