Ultrasonic Anti-Spoofing Algorithm
==========================
This file provides user interface documentation, including how to run the code and controls available while the code runs.

How to Run the Code
–––––––––––––––
All the source files except plotting.py should be put in a project in STM32CubeIDE and flashed to the STM32 with a USB connection. The ultrasonic sensors should be attached as appropriate to the pins of the STM32 and the STM32 should be powered and transfer data through a Micro-USB cable. Run plotting.py in the Python IDE of your choice on a PC that can support Python 3 with the necessary libraries installed. Be sure that the port name and N, L values in the Python file are the proper ones, aligning with the N, L values in the STM32 code and the port name of the PC used.

Live Controls
–––––––––––––––
– STM32 blue button: Toggles the attack mode of the attacking ultrasonic sensor between [No Attack, Jamming, Spoofing]. This can be used to demonstrate the algorithm's functionality recognizing attacks and testing how the signals work between the ultrasonic sensors.
– 'q' key on PC keyboard: Quits the Python program safely and entirely. Shuts down plots and ends the code. Useful if the plotting memory fills up, there is an error with serial, or the code needs to be shut down for some other reason.
– 'p' key on PC keyboard: Pauses the Python plots. Does not stop the sensors from reading data or serial from transmitting it, so when it is pressed again, data will continue to be transmitted live with no backlog. Useful for keeping certain data on-screen for screenshots or to demonstrate certain aspects of the program to an audience, like we did with our design expo.

Expected Behavior
–––––––––––––––
The ultrasonic sensors and Python visualization script should plot the data to a Matplotlib animation window. These should be live, but may be a little slower than live due to the processing overhead of the animation window. Increasing the sampling period of the defender sensor should help this. The type of attack, if an attack is detected, will be displayed in the title of the first plot (Distance vs. Time). There are no other console messages or diagnostic info, although occasionally error messages may pop up in the Python terminal. These can be disregarded as we have not found functionality to be interrupted from them.


//////////////////////////////////////////////

Overview
--------
This system combines STM32 firmware and Python visualization to detect ultrasonic sensor spoofing attacks. The STM32 handles real-time sensor data processing while a Python script provides live visualization of raw data, filtered signals, and frequency-domain analysis.

Hardware Setup
--------------
- STM32 NUCLEO-L4R5ZI-P board
- Defender Sensor: TRIG=PC10, ECHO=PC11
- Attacker Sensor: TRIG=PC8, ECHO=PC9
- USB Connection: Micro-USB cable for power and data
- PC running Python: Requires USB serial port access

How to Run
----------
1. STM32 Firmware
   - Import all project files into STM32CubeIDE
   - Build and flash to board via ST-LINK
   - Ensure serial port is free for Python connection

2. Python Visualization
   - Requirements: Python 3.9+, `pyserial`, `matplotlib`, `numpy`
   - Run: `python plotting.py --port <COM_PORT> --N 40 --L 40`
   - Parameters must match STM32 code settings:
     - N: FFT window size (default 40)
     - L: Stride length (default 40)
     - --port: Serial port (e.g., COM3 on Windows)

3. System Startup Order
   1. Power STM32 board
   2. Start Python script
   3. Wait for "Serial connection established" message

User Interface
--------------
### Hardware Controls
- STM32 Blue Button (PF5)
  - Single Press: Cycle attack modes:

    No Attack → Jamming (50ms pulses) → Random Spoofing (500-1500ms) → No Attack

### PC Controls
- 'q' Key: Safe shutdown of Python visualization
  - Closes plots and serial connection
  - Use for program termination or recovery from errors
- 'p' Key: Pause/resume plotting
  - Freezes display while continuing data acquisition
  - No data backlog - resumes with latest samples

Operation Overview
-----------------
1. Normal Operation
   - Defender sensor updates every 50ms
   - UART streams: `RAW_DIST FILTERED_DIST FFT_BINS...`
   - Python displays:
     - Time-domain plot (distance vs time)
     - Spectrogram (frequency vs time)
     - Attack status in plot title

2. Attack Modes
   - Jamming: Regular 50ms ultrasonic bursts
   - Spoofing: Randomized pulse intervals
   - Detection triggers visible as:
     - High-frequency components in spectrogram
     - Mismatch between raw/filtered distances

3. Performance Notes
   - ~200ms end-to-end latency (sensor→STM32→PC)
   - CPU Usage:
     - STM32: 65-70% (peaks during FFT)
     - Python: 15-20% (matplotlib overhead)

Troubleshooting
---------------
| Symptom               | Solution                                  |
|-----------------------|------------------------------------------|
| No Python plots       | Check COM port and baud rate (115200)    |
| Gaps in data          | Reduce N/L values or increase sampling   |
| "Serial busy" errors  | Disconnect IDE serial monitor first      |
| Frozen visualization  | Press 'p' twice to reset buffer          |

Expected Behavior
-----------------
- Successful Startup
  - STM32 blue LED solid on
  - Python console shows connection message
  - Matplotlib window with 3 subplots:
    1. Distance vs Time (attack status in title)
    2. Filtered vs Raw comparison
    3. Frequency spectrum

- During Attacks
  - Jamming: Regular spikes in raw distance plot
  - Spoofing: Random high-frequency FFT components

- Error Handling
  - Python ignores serial framing errors automatically
  - STM32 auto-reconnects on USB replug
